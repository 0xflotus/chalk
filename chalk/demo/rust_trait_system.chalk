// An experiment to be sure.
//
// Relies on other rust_*chalk files, so run like:
//
//     cargo run -- -p demo/rust*chalk -g "<your goal here>"
//
// Sample goals:
//
//     type: ref[X, i32] equals_type: ?T if: ?O, is_obligation_list: ?O

// Environment:
//
//     (lifetimes: [...])
//
// Stores names of regions and type parameters that are in scope.

empty_environment: (lifetimes: Nil).
environment: (lifetimes: ?Ls) contains_lifetimes: ?Ls.
environment: (lifetimes: ?Ls) with_lifetime: ?L is: (lifetimes: [?L, ?LS]).
environment: (lifetimes: ?Ls) contains_lifetime: ?L :-
    ?L in_list: ?Ls.

// Types:
is_type: i32.
is_type: u32.
is_type: str.
is_type: array[?T] :- is_type: ?T.
is_type: ref[?LT, ?T] :- is_lifetime: ?LT, is_type: ?T.
is_type: ref_mut[?LT, ?T] :- is_lifetime: ?LT, is_type: ?T.
is_type: fn[?A, ?R] :- is_type: ?A, is_type: ?R.
is_type: tup[?A, ?B] :- is_type: ?A, is_type: ?B.
is_type: for[?LT, ?T] :- implies(is_lifetime: ?LT => is_type: ?T).

// Lifetimes: any identifier. Lifetimes scoping is controlled by implications above.
// is_lifetime: ?T.

// Obligations list:
is_obligation_list: Nil.
is_obligation_list: (?A = ?B).
is_obligation_list: [?O1, ?O2] :- is_obligation_list: ?O1, is_obligation_list: ?O2.

// type: ?T equals_type: ?U in: ?E if: ?O.
type: i32 equals_type: i32 in: ?E if: Nil.
type: u32 equals_type: u32 in: ?E if: Nil.
type: str equals_type: str in: ?E if: Nil.
type: array[?T] equals_type: array[?U] in: ?E if: ?O :-
    type: ?T equals_type: ?U in: ?E if: ?O.
type: ref[?LT, ?T] equals_type: ref[?LU, ?U] in: ?E if: [?LT = ?LU, ?O] :-
    type: ?T equals_type: ?U in: ?E if: ?O.    
type: ref_mut[?LT, ?T] equals_type: ref_mut[?LU, ?U] in: ?E if: [?LT = ?LU, ?O] :-
    type: ?T equals_type: ?U in: ?E if: ?O.
type: fn[?AT, ?RT] equals_type: fn[?AU, ?RU] in: ?E if: [?OA, ?OR] :-
    type: ?AT equals_type: ?AU in: ?E if: ?OA,
    type: ?RT equals_type: ?RU in: ?E if: ?OR.
type: tup[?AT, ?RT] equals_type: tup[?AU, ?RU] in: ?E if: [?OA, ?OR] :-
    type: ?AT equals_type: ?AU in: ?E if: ?OA,
    type: ?RT equals_type: ?RU in: ?E if: ?OR.
// type: for[?LT, ?T] equals_type: for[?LU, ?U] in: ?E if: ?O :-

// type: ?T with_lifetime: (?L1 = ?L2) is_type: ?U.
//
// Assumption: ?L1 not defined in the environment ?E.
type: i32 with_lifetime: (?L1 = ?L2) is_type: i32.
type: u32 with_lifetime: (?L1 = ?L2) is_type: u32.
type: str with_lifetime: (?L1 = ?L2) is_type: str.
type: array[?T] with_lifetime: (?L1 = ?L2) is_type: array[?U] :-
    type: ?T with_lifetime: (?L1 = ?L2) is_type: ?U.
type: ref[?L1, ?T] with_lifetime: (?L1 = ?L2) is_type: ref[?L2, T].
type: ref[?L3, ?T] with_lifetime: (?L1 = ?L2) is_type: ref[?L2, T].
type: ref_mut[?L1, ?T] with_lifetime: (?L1 = ?L2) is_type: ref_mut[?L2, T].
type: ref_mut[?L3, ?T] with_lifetime: (?L1 = ?L2) is_type: ref[?L2, T].
type: fn[?A1, ?R1] with_lifetime: (?L1 = ?L2) is_type: fn[?A2, ?R2] :-
    type: ?A1 with_lifetime: (?L1 = ?L2) is_type: ?A2,
    type: ?R1 with_lifetime: (?L1 = ?L2) is_type: ?R2.
type: tup[?A1, ?R1] with_lifetime: (?L1 = ?L2) is_type: tup[?A2, ?R2] :-
    type: ?A1 with_lifetime: (?L1 = ?L2) is_type: ?A2,
    type: ?R1 with_lifetime: (?L1 = ?L2) is_type: ?R2.
type: for[?L1, ?T] with_lifetime: (?L1 = ?L2) is_type: for[?L1, ?T].
type: for[?L3, ?T] with_lifetime: (?L1 = ?L2) is_type: for[?L3, ?U] :-
    type: ?T with_lifetime: (?L1 = ?L2) is_type: ?U.
