// An experiment to be sure.
//
// Relies on other rust_*chalk files, so run like:
//
//     cargo run -- -p demo/rust*chalk -g "<your goal here>"
//
// Sample goals:
//
//     type: ref[X, i32] equals_type: ?T if: ?O, is_obligation_list: ?O

// Environment:
//
//     (lifetimes: [...])
//
// Stores names of regions and type parameters that are in scope.

// Types:
is_type: i32.
is_type: u32.
is_type: str.
is_type: array[?T] :- is_type: ?T.
is_type: ref[?LT, ?T] :- is_lifetime: ?LT, is_type: ?T.
is_type: ref_mut[?LT, ?T] :- is_lifetime: ?LT, is_type: ?T.
is_type: fn[?A, ?R] :- is_type: ?A, is_type: ?R.
is_type: tup[?A, ?B] :- is_type: ?A, is_type: ?B.
is_type: for[?LT, ?T] :- (is_lifetime: ?LT => is_type: ?T).

// Lifetimes: any identifier. Lifetimes scoping is controlled by implications above.
// is_lifetime: ?T.

// Obligations list:
is_obligation_list: Nil.
is_obligation_list: (?A = ?B).
is_obligation_list: [?O1, ?O2] :- is_obligation_list: ?O1, is_obligation_list: ?O2.

// type: ?T equals_type: ?U if: ?O.
    // normalize_type: ?U to_type: ?U1 if: ?OB,
type: ?T equals_type: ?U if: [?OA, [?OB, ?OC]] :-
    normalize_type: ?T to_type: ?T1 if: ?OA,
    ?U1 = ?U, ?OB = Nil,
    normalized_type: ?T1 equals_type: ?U1 if: ?OC.
    
normalized_type: i32 equals_type: i32 if: Nil.
normalized_type: u32 equals_type: u32 if: Nil.
normalized_type: str equals_type: str if: Nil.
normalized_type: array[?T] equals_type: array[?U] if: ?O :-
    type: ?T equals_type: ?U if: ?O.
normalized_type: ref[?LT, ?T] equals_type: ref[?LU, ?U] if: [?LT = ?LU, ?O] :-
    type: ?T equals_type: ?U if: ?O.    
normalized_type: ref_mut[?LT, ?T] equals_type: ref_mut[?LU, ?U] if: [?LT = ?LU, ?O] :-
    type: ?T equals_type: ?U if: ?O.
normalized_type: fn[?AT, ?RT] equals_type: fn[?AU, ?RU] if: [?OA, ?OR] :-
    type: ?AT equals_type: ?AU if: ?OA,
    type: ?RT equals_type: ?RU if: ?OR.
normalized_type: tup[?AT, ?RT] equals_type: tup[?AU, ?RU] if: [?OA, ?OR] :-
    type: ?AT equals_type: ?AU if: ?OA,
    type: ?RT equals_type: ?RU if: ?OR.
normalized_type: Project[?TraitRef1, ?Item] equals_type: Project[?TraitRef2, ?Item] if: ?O :-
    trait_ref: ?TraitRef1 equals_trait_ref: ?TraitRef2 if: ?O.

normalize_type: i32 to_type: i32 if: Nil.
normalize_type: u32 to_type: u32 if: Nil.
normalize_type: str to_type: str if: Nil.
normalize_type: array[?T] to_type: array[?T] if: Nil.
normalize_type: ref[?LT, ?T] to_type: ref[?LT, ?T] if: Nil.
normalize_type: ref_mut[?LT, ?T] to_type: ref_mut[?LT, ?T] if: Nil.
normalize_type: fn[?A, ?R] to_type: fn[?A, ?R] if: Nil.
normalize_type: tup[?A, ?B] to_type: tup[?A, ?B] if: Nil.
normalize_type: Project[?TraitRef, ?Item] to_type: Project[?TraitRef, ?Item] if: Nil :-
    !{exists{?T -> exists{?O -> project: ?Item from: ?TraitRef to: ?T if: ?O}}}.
normalize_type: Project[?TraitRef, ?Item] to_type: ?U if: [?O1, ?O2] :-
    project: ?Item from: ?TraitRef to: ?T if: ?O1,
    normalize_type: ?T to_type: ?U if: ?O2.

// Example struct:
normalize_type: Option[?T] to_type: Option[?T] if: Nil.
normalized_type: Option[?T] equals_type: Option[?U] if: ?O :-
    type: ?T equals_type: ?U if: ?O.


