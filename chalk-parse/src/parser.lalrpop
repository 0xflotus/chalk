use ast::*;
use lalrpop_intern::{intern, InternedString};
use std::iter::once;

grammar;

pub Program: Program = {
    Item+ => Program { items: <>.into_iter().filter_map(|x| x).collect() },
};

Item: Option<Item> = {
    Comment => None,
    <a:Application> "." => Some(Item::Fact(a)),
    Rule => Some(Item::Rule(<>)),
};

Rule: Rule = {
    <s0:@L> <a:Application> ":-" <f:Goal> "." <s1:@R> => Rule {
        span: Span::new(s0, s1),
        consequence: a,
        condition: f
    },
};

pub Goal: Fact = Fact<FactData>;

Fact<D>: Fact = {
    <s0:@L> <d:D> <s1:@R> =>
        Fact {
            span: Span::new(s0, s1),
            data: d
        }
};

FactData: Box<FactData> = {
    FactDataAnd
};

FactDataAnd: Box<FactData> = {
    FactDataOr,
    <l:Fact<FactDataAnd>> "," <r:Fact<FactDataOr>> => Box::new(FactData::And(l, r)),
};

FactDataOr: Box<FactData> = {
    FactDataFunc,
    <l:Fact<FactDataOr>> ";" <r:Fact<FactDataFunc>> => Box::new(FactData::Or(l, r)),
};

FactDataFunc: Box<FactData> = {
    FactDataApply,
    "(" <l:Goal> "=>" <r:Goal> ")" =>
        Box::new(FactData::Implication(l, r)),
    "exists" "{" <v:Variable> "->" <b:Goal> "}" =>
        Box::new(FactData::Exists(v, b)),
    "forall" "{" <v:Variable> "->" <b:Goal> "}" =>
        Box::new(FactData::ForAll(v, b)),
    "if" "{" <a:Goal> "}" "then" "{" <b:Goal> "}" "else" "{" <c:Goal> "}" =>
        Box::new(FactData::IfThenElse(a, b, c)),
    "true" =>
        Box::new(FactData::True),
    "false" =>
        Box::new(FactData::False),
};

FactDataApply: Box<FactData> = {
    Application => Box::new(FactData::Apply(<>)),
};

Application: Application = {
    KeywordApplication,
    IndexedApplication,
};

IndexedApplication: Application = {
    <s0:@L> <id:Identifier> "(" <appls:BitArguments> ")" <s1:@R> => {
        let oper_bit = Bit {
            span: Span::new(s0, s1),
            kind: BitKind::Operator(Operator::Parens(id))
        };
        Application {
            span: Span::new(s0, s0),
            bits: Some(oper_bit).into_iter().chain(appls).collect(),
        }
    },
    <s0:@L> <id:Identifier?> "[" <appls:BitArguments> "]" <s1:@R> => {
        let oper_bit = Bit {
            span: Span::new(s0, s1),
            kind: BitKind::Operator(Operator::SquareBrackets(id))
        };
        Application {
            span: Span::new(s0, s0),
            bits: Some(oper_bit).into_iter().chain(appls).collect()
        }
    },
};

KeywordApplication: Application = {
    <s0:@L> <bits:KeywordApplicationBits> <s1:@R> => {
        Application {
            span: Span::new(s0, s1),
            bits: bits
        }
    }
};

KeywordApplicationBits: Vec<Bit> = {
    <head:BitOperator> => vec![head],
    <head:BitValue?> <body:(BitOperator BitValue)+> <tail:BitOperator?> =>
        head.into_iter()
            .chain(body.into_iter().flat_map(|(o, v)| once(o).chain(once(v))))
            .chain(tail)
            .collect(),
};

BitArguments: Vec<Bit> = {
    Vec0<BitArgument>
};

BitArgument: Bit = {
    <s0:@L> <a:KeywordApplication> <s1:@R> => {
        let span = Span::new(s0, s1);
        Bit {
            span: span,
            kind: BitKind::Value(Value {
                span: span,
                kind: ValueKind::Application(a)
            }),
        }
    },
    BitValue,
};

OperatorValue: (Operator, Value) = {
    Operator Value => (<>),
};

BitOperator: Bit = {
    <s0:@L> <head:Operator> <s1:@R> =>
        Bit { span: Span::new(s0, s1), kind: BitKind::Operator(head) },
};

Operator: Operator = {
    r"([:alpha:]|_)([:alnum:]|_)*:" => Operator::Colon(intern(<>)),
    "if" => Operator::Colon(intern(<>)),
    "then" => Operator::Colon(intern(<>)),
    "else" => Operator::Colon(intern(<>)),
    "exists" => Operator::Colon(intern(<>)),
    "forall" => Operator::Colon(intern(<>)),
    "implies" => Operator::Colon(intern(<>)),
    r"[-|!@#$%^&*=+:?~<>][-|!@#$%^&*=+/:?~<>]*|/[-|!@#$%^&*=+:?~<>]*" => Operator::Symbols(intern(<>)),
};

BitValue: Bit = {
    <s0:@L> <head:Value> <s1:@R> =>
        Bit { span: Span::new(s0, s1), kind: BitKind::Value(head) },
};

Value: Value = {
    <s0:@L> <k:ValueKind> <s1:@R> =>
        Value { span: Span::new(s0, s1), kind: k },
};

ValueKind: ValueKind = {
    Atom => ValueKind::Atom(<>),
    Variable => ValueKind::Variable(<>),
    "(" <KeywordApplication> ")" => ValueKind::Application(<>),
    "(" <ValueKind> ")",
    "_" => ValueKind::Wildcard,
    IndexedApplication => ValueKind::Application(<>),
};

Atom: Atom = {
    <s:r"'[^']+'"> => Atom { id: intern(&s[1..s.len() - 1]) },
    Identifier => Atom { id: <> },
};

Variable: Variable = {
    r"\?([:alpha:]|_)([:alnum:]|_)*" => Variable { id: intern(<>) },
};

Identifier: InternedString = {
    r"([:alpha:]|_)([:alnum:]|_)*" => intern(<>),
};

Vec1<V>: Vec<V> = {
    <v:V> => vec![v],
    <vs:Vec1<V>> "," => vs,
    <vs:Vec1<V>> "," <v:V> => {
        let mut vs = vs;
        vs.push(v);
        vs
    },
};

Vec0<V>: Vec<V> = {
    <v0:(<V> ",")*> <v1:V?> => {
        let mut v0 = v0;
        v0.extend(v1);
        v0
    }
};

Comment = {
    r"//.*",
};
