use ast::*;
use lalrpop_intern::{intern, InternedString};
use std::iter::once;

grammar;

pub Program: Program = {
    Item+ => Program { items: <> },
};

Item: Item = {
    <a:Application> "." => Item::Fact(a),
    Rule => Item::Rule(<>),
};

Rule: Rule = {
    <s0:@L> <a:Application> ":-" <f:Fact<FactData>> "." <s1:@R> => Rule {
        span: Span::new(s0, s1),
        consequence: a,
        condition: f
    },
};

pub Goal: Fact = Fact<FactData>;

Fact<D>: Fact = {
    <s0:@L> <d:D> <s1:@R> =>
        Fact {
            span: Span::new(s0, s1),
            data: d
        }
};

FactData: Box<FactData> = {
    FactDataAnd
};

FactDataAnd: Box<FactData> = {
    FactDataOr,
    <l:Fact<FactDataAnd>> "," <r:Fact<FactDataOr>> => Box::new(FactData::And(l, r)),
};

FactDataOr: Box<FactData> = {
    FactDataFunc,
    <l:Fact<FactDataOr>> ";" <r:Fact<FactDataFunc>> => Box::new(FactData::Or(l, r)),
};

FactDataFunc: Box<FactData> = {
    FactDataApply,
    "implies" "(" <l:Fact<FactData>> "=>" <r:Fact<FactData>> ")" =>
        Box::new(FactData::Implication(l, r)),
    "exists" "(" <v:Variable> "->" <b:Fact<FactData>> ")" =>
        Box::new(FactData::Exists(v, b)),
    "forall" "(" <v:Variable> "->" <b:Fact<FactData>> ")" =>
        Box::new(FactData::ForAll(v, b)),
};

FactDataApply: Box<FactData> = {
    Application => Box::new(FactData::Apply(<>)),
};

Application: Application = {
    <s0:@L> <bits:ApplicationBits> <s1:@R> => {
        Application {
            span: Span::new(s0, s1),
            bits: bits
        }
    }
};

ApplicationBits: Vec<Bit> = {
    <head:BitValue> => vec![head],
    <head:BitOperator> => vec![head],
    <head:BitValue?> <body:(BitOperator BitValue)+> <tail:BitOperator?> =>
        head.into_iter()
            .chain(body.into_iter().flat_map(|(o, v)| once(o).chain(once(v))))
            .chain(tail)
            .collect(),
    <s0:@L> <id:Identifier> "(" <appls:BitApplications> ")" <s1:@R> => {
        let oper_bit = Bit {
            span: Span::new(s0, s1),
            kind: BitKind::Operator(Operator::Parens(id))
        };
        Some(oper_bit).into_iter().chain(appls).collect()
    },
    <s0:@L> <id:Identifier> "[" <appls:BitApplications> "]" <s1:@R> => {
        let oper_bit = Bit {
            span: Span::new(s0, s1),
            kind: BitKind::Operator(Operator::SquareBrackets(id))
        };
        Some(oper_bit).into_iter().chain(appls).collect()
    },
};

BitApplications: Vec<Bit> = {
    Vec0<BitApplication>
};

BitApplication: Bit = {
    <s0:@L> <a:Application> <s1:@R> => {
        let span = Span::new(s0, s1);
        Bit {
            span: span,
            kind: BitKind::Value(Value {
                span: span,
                kind: ValueKind::Application(a)
            }),
        }
    }
};

OperatorValue: (Operator, Value) = {
    Operator Value => (<>),
};

BitOperator: Bit = {
    <s0:@L> <head:Operator> <s1:@R> =>
        Bit { span: Span::new(s0, s1), kind: BitKind::Operator(head) },
};

Operator: Operator = {
    r"[A-Za-z][A-Za-z0-9_]*:" => Operator::Colon(intern(<>)),
    r"[-|!@#$%^&*=+/:?~<>]+" => Operator::Symbols(intern(<>)),
};

BitValue: Bit = {
    <s0:@L> <head:Value> <s1:@R> =>
        Bit { span: Span::new(s0, s1), kind: BitKind::Value(head) },
};

Value: Value = {
    <s0:@L> <k:ValueKind> <s1:@R> =>
        Value { span: Span::new(s0, s1), kind: k },
};

ValueKind: ValueKind = {
    Atom => ValueKind::Atom(<>),
    Variable => ValueKind::Variable(<>),
    "(" <Application> ")" => ValueKind::Application(<>),
    "_" => ValueKind::Wildcard,
};

Atom: Atom = {
    <s:r"'[^']+'"> => Atom { id: intern(&s[1..s.len() - 1]) },
};

Variable: Variable = {
    Identifier => Variable { id: <> },
};

Identifier: InternedString = {
    r"[A-Za-z][A-Za-z0-9_]*" => intern(<>),
};

Vec1<V>: Vec<V> = {
    <v:V> => vec![v],
    <vs:Vec1<V>> "," => vs,
    <vs:Vec1<V>> "," <v:V> => {
        let mut vs = vs;
        vs.push(v);
        vs
    },
};

Vec0<V>: Vec<V> = {
    <v0:(<V> ",")*> <v1:V?> => {
        let mut v0 = v0;
        v0.extend(v1);
        v0
    }
};
